<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: eve/EveSOF.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: eve/EveSOF.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>function EveSOF() {
    var data = null;
    var spriteEffect = null;

    function _get(obj, property, defaultValue) {
        if (property in obj) {
            return obj[property];
        }
        return defaultValue;
    }

    /**
     * @return {string}
     */
    function GetShaderPrefix(isAnimated) {
        return isAnimated ? _get(data['generic'], 'shaderPrefixAnimated', '') : _get(data['generic'], 'shaderPrefix', '');
    }

    function ModifyTextureResPath(path, name, area, faction, commands) {
        var pathInsert = null;
        if (_get(faction, 'resPathInsert', '').length)
        {
            pathInsert = faction.resPathInsert;
        }
        if ('respathinsert' in commands &amp;&amp; commands.respathinsert.length == 1)
        {
            if (commands.respathinsert[0] == 'none')
            {
                return path;
            }
            else
            {
                pathInsert = commands.respathinsert[0];
            }
        }
        if (name == 'MaterialMap' || name == 'PaintMaskMap' || name == 'PmdgMap') {
            var index = path.lastIndexOf('/');
            var pathCopy = path;
            if (index >= 0) {
                pathCopy = path.substr(0, index + 1) + pathInsert + '/' + path.substr(index + 1);
            }
            index = pathCopy.lastIndexOf('_');
            if (index >= 0) {
                pathCopy = pathCopy.substr(0, index) + '_' + pathInsert + pathCopy.substr(index);
                var textureOverrides = _get(area, 'textureOverrides', {});
                if ((name in  textureOverrides) &amp;&amp; (faction.name in textureOverrides[name])) {
                    return pathCopy;
                }
            }
        }
        return path;
    }

    /**
     * @return {string}
     */
    function ModifyShaderPath(shader, isSkinned) {
        var prefix = GetShaderPrefix(isSkinned);
        shader = '/' + shader;
        var index = shader.lastIndexOf('/');
        return shader.substr(0, index + 1) + prefix + shader.substr(index + 1);
    }

    function FindPrefix(prefixes, name)
    {
        for (var m = 0; m &lt; prefixes.length; ++m)
        {
            if (name.substr(0, prefixes[m].length) == prefixes[m])
            {
                return m;
            }
        }
        return null;
    }

    function GetOverridenParameter(name, area, commands, race)
    {
        var prefixes, materialIndex, materialData, shortName;
        if ('mesh' in commands)
        {
            prefixes = data.generic.materialPrefixes;
            materialIndex = FindPrefix(prefixes, name);
            if (materialIndex !== null &amp;&amp; materialIndex &lt; commands.mesh.length &amp;&amp; (_get(area, 'blockedMaterials', 0) &amp; (1 &lt;&lt; materialIndex)) == 0)
            {
                materialData = _get(data.material, commands.mesh[materialIndex], null);
                if (materialData)
                {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }
        prefixes = data.generic.patternMaterialPrefixes;
        materialIndex = FindPrefix(prefixes, name);
        if ('pattern' in commands)
        {
            if (materialIndex !== null &amp;&amp; 1 + materialIndex &lt; commands.pattern.length)
            {
                materialData = _get(data.material, commands.pattern[1 + materialIndex], null);
                if (materialData)
                {
                    shortName = name.substr(prefixes[materialIndex].length);
                    return _get(materialData.parameters, shortName, undefined);
                }
            }
        }

        if (materialIndex !== null)
        {
            materialData = _get(data.material, race.defaultPatternLayer1MaterialName, null);
            if (materialData)
            {
                shortName = name.substr(prefixes[materialIndex].length);
                return _get(materialData.parameters, shortName, undefined);
            }
        }
    }

    function GetAddressMode(projectionType)
    {
        switch (projectionType)
        {
            case 2:
                return 4;
            case 1:
                return 3;
            default:
                return 1;
        }
    }

    function FillMeshAreas(areas, areasName, hull, faction, race, pattern, commands, shaderOverride) {
        var hullAreas = _get(hull, areasName, []);
        for (var i = 0; i &lt; hullAreas.length; ++i) {
            var area = hullAreas[i];
            var effect = new Tw2Effect();
            effect.effectFilePath = data['generic']['areaShaderLocation'] + ModifyShaderPath(shaderOverride ? shaderOverride : area.shader, hull['isSkinned']);
            var names = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'parameters', []);
            for (var j = 0; j &lt; names.length; ++j) {
                var name = names[j];
                var param = GetOverridenParameter(name, area, commands, race);
                param = param || _get(_get(_get(data.generic.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(race.hullAreas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(_get(faction.areas, area.name, {}), 'parameters', {}), name);
                param = param || _get(_get(area, 'parameters', {}), name);
                if (param) {
                    effect.parameters[name] = new Tw2Vector4Parameter(name, param);
                }
            }

            var hullTextures = _get(area, 'textures', []);
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j))
                {
                    var path = hullTextures[j];
                    path = ModifyTextureResPath(path, j, area, faction, commands);
                    effect.parameters[j] = new Tw2TextureParameter(j, path);
                }
            }

            for (j = 0; j &lt; pattern.layers.length; ++j)
            {
                if (pattern.layers[j] &amp;&amp; !(pattern.layers[j].textureName in effect.parameters))
                {
                    var patternTex = new Tw2TextureParameter(pattern.layers[j].textureName);
                    patternTex.resourcePath = pattern.layers[j].textureResFilePath;
                    patternTex.useAllOverrides = true;
                    patternTex.addressUMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeU', 0));
                    patternTex.addressVMode = GetAddressMode(_get(pattern.layers[j], 'projectionTypeV', 0));
                    patternTex.Initialize();
                    effect.parameters[pattern.layers[j].textureName] = patternTex;
                }
            }

            var defaultTextures = _get(_get(data['generic']['areaShaders'], area.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures)
            {
                if (defaultTextures.hasOwnProperty(texName))
                {
                    if (!(texName in effect.parameters))
                    {
                        effect.parameters[texName] = new Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var newArea = new Tw2MeshArea();
            newArea.name = area.name;
            newArea.effect = effect;
            newArea.index = _get(area, 'index', 0);
            newArea.count = _get(area, 'count', 1);
            areas.push(newArea);
        }

    }
    function SetupMesh(ship, hull, faction, race, commands, pattern) {
        var mesh = new Tw2Mesh();
        mesh.geometryResPath = hull['geometryResFilePath'];
        ship.boundingSphereCenter[0] = hull.boundingSphere[0];
        ship.boundingSphereCenter[1] = hull.boundingSphere[1];
        ship.boundingSphereCenter[2] = hull.boundingSphere[2];
        ship.boundingSphereRadius = hull.boundingSphere[3];
        FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'transparentAreas', []), 'transparentAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'additiveAreas', []), 'additiveAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'decalAreas', []), 'decalAreas', hull, faction, race, pattern, commands);
        FillMeshAreas(_get(mesh, 'depthAreas', []), 'depthAreas', hull, faction, race, pattern, commands);
        mesh.Initialize();
        ship.mesh = mesh;
        if ('shapeEllipsoidCenter' in hull) {
            ship.shapeEllipsoidCenter = hull.shapeEllipsoidCenter;
        }
        if ('shapeEllipsoidRadius' in hull) {
            ship.shapeEllipsoidRadius = hull.shapeEllipsoidRadius;
        }
    }

    function SetupPattern(hull, race, commands) {
        var pattern = {patterns: [], layers: []};
        if ('pattern' in commands)
        {
            var p = {};
            for (var k = 0; k &lt; data.pattern.length; ++k)
            {
                if (data.pattern[k].name == commands.pattern[0])
                {
                    p = data.pattern[k];
                    break;
                }
            }
            var layer = _get(p, 'layer1', null);
            if (layer)
            {
                pattern.layers.push(layer)
            }
            layer = _get(p, 'layer2', null);
            if (layer)
            {
                pattern.layers.push(layer)
            }
            var projections = _get(p, 'projections', []);
            for (var i = 0; i &lt; projections.length; ++i)
            {
                if (projections[i].name == hull.name)
                {
                    p = projections[i];
                    layer = _get(p, 'transformLayer1', null);
                    if (layer)
                    {
                        pattern.patterns.push(layer)
                    }
                    layer = _get(p, 'transformLayer2', null);
                    if (layer)
                    {
                        pattern.patterns.push(layer)
                    }
                }
            }
        }
        else if (_get(hull, 'defaultPattern'))
        {
            p = _get(hull, 'defaultPattern', {});
            layer = _get(p, 'transformLayer1', null);
            if (layer)
            {
                pattern.patterns.push(layer)
            }
            layer = _get(p, 'transformLayer2', null);
            if (layer)
            {
                pattern.patterns.push(layer)
            }
            p = _get(race, 'defaultPattern', {});
            layer = _get(p, 'layer1', null);
            if (layer)
            {
                pattern.layers.push(layer)
            }
            layer = _get(p, 'layer2', null);
            if (layer)
            {
                pattern.layers.push(layer)
            }
        }
        return pattern;
    }

    function SetupCustomMasks(ship, pattern) {
        for (var i = 0; i &lt; pattern.patterns.length; ++i)
        {
            if (pattern.patterns[i] &amp;&amp; pattern.layers[i])
            {
                var p = pattern.patterns[i];
                var l = pattern.layers[i];
                ship.AddCustomMask(
                    _get(p, 'position', vec3.create([0, 0, 0])),
                    _get(p, 'scaling', vec3.create([1, 1, 1])),
                    _get(p, 'rotation', quat4.create([0, 0, 0, 1])),
                    _get(p, 'isMirrored', false),
                    _get(l, 'materialSource', 0),
                    quat4.create([_get(l, 'isTargetMtl1', true) ? 1 : 0, _get(l, 'isTargetMtl2', true) ? 1 : 0,
                        _get(l, 'isTargetMtl3', true) ? 1 : 0, _get(l, 'isTargetMtl4', true) ? 1 : 0]));
            }
        }
    }

    function SetupDecals(ship, hull, faction) {
        var hullDecals = _get(hull, 'hullDecals', []);
        for (var i = 0; i &lt; hullDecals.length; ++i) {
            var hullDecal = hullDecals[i];
            var factionDecal = null;
            var factionIndex = 'group' + _get(hullDecal, 'groupIndex', -1);
            if (faction.decals &amp;&amp; (factionIndex in faction.decals)) {
                factionDecal = faction.decals[factionIndex];
            }
            if (factionDecal &amp;&amp; !factionDecal['isVisible']) {
                continue;
            }
            var effect = new Tw2Effect();
            if (factionDecal &amp;&amp; factionDecal.shader &amp;&amp; factionDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + factionDecal.shader;
            }
            else if (hullDecal.shader &amp;&amp; hullDecal.shader.length) {
                effect.effectFilePath = data['generic']['decalShaderLocation'] + '/' + GetShaderPrefix(false) + hullDecal.shader;
            }
            else {
                continue;
            }
            var hullParameters = _get(hullDecal, 'parameters', {});
            for (var j in hullParameters) {
                if (hullParameters.hasOwnProperty(j)) {
                    effect.parameters[j] = new Tw2Vector4Parameter(j, hullParameters[j]);
                }
            }
            var hullTextures = _get(hullDecal, 'textures', {});
            for (j in hullTextures) {
                if (hullTextures.hasOwnProperty(j)) {
                    effect.parameters[j] = new Tw2TextureParameter(j, hullTextures[j]);
                }
            }
            if (factionDecal) {
                var factionParameters = _get(factionDecal, 'parameters', {});
                for (j in factionParameters) {
                    if (factionParameters.hasOwnProperty(j)) {
                        effect.parameters[j] = new Tw2Vector4Parameter(j, factionParameters[j]);
                    }
                }
                var factionTextures = _get(factionDecal, 'textures', {});
                for (j in factionTextures) {
                    if (factionTextures.hasOwnProperty(j) &amp;&amp; !(j in effect.parameters))
                    {
                        effect.parameters[j] = new Tw2TextureParameter(j, factionTextures[j]);
                    }
                }
            }

            var defaultTextures = _get(_get(data['generic']['decalShaders'], hullDecal.shader, {}), 'defaultTextures', {});
            for (var texName in defaultTextures)
            {
                if (defaultTextures.hasOwnProperty(texName))
                {
                    if (!(texName in effect.parameters))
                    {
                        effect.parameters[texName] = new Tw2TextureParameter(texName, defaultTextures[texName]);
                    }
                }
            }

            effect.Initialize();

            var decal = new EveSpaceObjectDecal();
            vec3.set(_get(hullDecal, 'position', [0, 0, 0]), decal.position);
            quat4.set(_get(hullDecal, 'rotation', [0, 0, 0, 1]), decal.rotation);
            vec3.set(_get(hullDecal, 'scaling', [1, 1, 1]), decal.scaling);
            decal.parentBoneIndex = _get(hullDecal, 'boneIndex', -1);
            decal.indexBuffer = new Uint16Array(hullDecal.indexBuffer);
            decal.decalEffect = effect;
            decal.name = _get(hullDecals[i], 'name', '');
            if ('groupIndex' in hullDecals[i]) {
                    decal.groupIndex = hullDecals[i].groupIndex; 
            }
            decal.Initialize();
            ship.decals.push(decal);
        }
    }

    function SetupInstancedMeshes(ship, hull, faction, race, commands, pattern)
    {
        var instancedMeshes = _get(hull, 'instancedMeshes', []);
        for (var i = 0; i &lt; instancedMeshes.length; ++i)
        {
            var him = instancedMeshes[i];
            var mesh = new Tw2InstancedMesh();
            mesh.instanceGeometryResPath = him.instanceGeometryResPath;
            mesh.geometryResPath = him.geometryResPath;
            mesh.Initialize();

            FillMeshAreas(_get(mesh, 'opaqueAreas', []), 'opaqueAreas', hull, faction, race, pattern, commands, him.shader);

            var child = new EveChildMesh();
            child.mesh = mesh;
            ship.effectChildren.push(child);
        }
    }

    function SetupSpriteSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spriteSets', []);
        var factionSets = _get(faction, 'spriteSets', {});
        for (var i = 0; i &lt; hullSets.length; ++i) {
            var spriteSet = new EveSpriteSet(true, hull['isSkinned'] &amp;&amp; hullSets[i]['skinned']);
            spriteSet.name = _get(hullSets[i], 'name', '');
            spriteSet.effect = spriteEffect;
            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j &lt; hullData.length; ++j) {
                if (!('group' + _get(hullData[j], 'groupIndex', -1) in factionSets)) {
                    continue;
                }
                var factionSet = factionSets['group' + _get(hullData[j], 'groupIndex', -1)];
                var item = new EveSpriteSetItem();
                if ('color' in factionSet) {
                    item.color = factionSet.color;
                }
                item.blinkPhase = _get(hullData[j], 'blinkPhase', 0);
                item.blinkRate = _get(hullData[j], 'blinkRate', 0.1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.falloff = _get(hullData[j], 'falloff', 0);
                item.maxScale = _get(hullData[j], 'maxScale', 10);
                item.minScale = _get(hullData[j], 'minScale', 1);
                item.name = _get(hullData[j], 'name', '');
                if ('groupIndex' in hullData[j]) {
                    item.groupIndex = hullData[j].groupIndex; 
                }
                item.groupName = factionSet.name;
                if ('position' in hullData[j]) {
                    item.position = hullData[j].position;
                }
                spriteSet.sprites.push(item);
            }
            spriteSet.Initialize();
            ship.spriteSets.push(spriteSet);
        }
    }

    function _scale(a, b, c) {
        c[0] = a[0] * b;
        c[1] = a[1] * b;
        c[2] = a[2] * b;
        c[3] = a[3] * b;
    }

    function SetupSpotlightSets(ship, hull, faction) {
        var hullSets = _get(hull, 'spotlightSets', []);
        var factionSets = _get(faction, 'spotlightSets', {});
        for (var i = 0; i &lt; hullSets.length; ++i) {
            var spotlightSet = new EveSpotlightSet();
            spotlightSet.name = _get(hullSets[i], 'name', '');
            spotlightSet.coneEffect = new Tw2Effect();
            spotlightSet.glowEffect = new Tw2Effect();
            if (hullSets[i]['skinned']) {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_spotlightglow.fx';
            }
            else {
                spotlightSet.coneEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightcone.fx';
                spotlightSet.glowEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/spotlightglow.fx';
            }
            spotlightSet.coneEffect.parameters['TextureMap'] = new Tw2TextureParameter('TextureMap', hullSets[i]['coneTextureResPath']);
            spotlightSet.glowEffect.parameters['TextureMap'] = new Tw2TextureParameter('TextureMap', hullSets[i]['glowTextureResPath']);
            spotlightSet.coneEffect.parameters['zOffset'] = new Tw2FloatParameter('zOffset', _get(hullSets[i], 'zOffset', 0));
            spotlightSet.coneEffect.Initialize();
            spotlightSet.glowEffect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j &lt; hullData.length; ++j) {
                var item = new EveSpotlightSetItem();
                item.name = _get(hullData[j], 'name', '');
                item.groupIndex = _get(hullData[j], 'groupIndex', -1);
                item.boneIndex = _get(hullData[j], 'boneIndex', 0);
                item.boosterGainInfluence = _get(hullData[j], 'boosterGainInfluence', 0);
                
                item.coneIntensity = _get(hullData[j], 'coneIntensity', 0);
                item.spriteIntensity = _get(hullData[j], 'spriteIntensity', 0);
                item.flareIntensity = _get(hullData[j], 'flareIntensity', 0);
                
                var factionSet = factionSets['group' + item.groupIndex];
                if (factionSet) {
                    quat4.set(_get(factionSet, 'coneColor', [0, 0, 0, 0]), item.coneColor);
                    quat4.set(_get(factionSet, 'spriteColor', [0, 0, 0, 0]), item.spriteColor);
                    quat4.set(_get(factionSet, 'flareColor', [0, 0, 0, 0]), item.flareColor);
                }
                
                item.spriteScale = _get(hullData[j], 'spriteScale', [1, 1, 1]);
                if ('transform' in hullData[j]) {
                    item.transform = hullData[j].transform;
                }
                else {
                    mat4.identity(item.transform);
                }
                spotlightSet.spotlightItems.push(item);
            }
            spotlightSet.Initialize();
            ship.spotlightSets.push(spotlightSet);
        }
    }

    function _assignIfExists(dest, src, attr) {
        if (attr in src) {
            dest[attr] = src[attr];
        }
    }

    function SetupPlaneSets(ship, hull, faction) {
        var hullSets = _get(hull, 'planeSets', []);
        var factionSets = _get(faction, 'planeSets', {});
        for (var i = 0; i &lt; hullSets.length; ++i) {
            var planeSet = new EvePlaneSet();
            planeSet.name = _get(hullSets[i], 'name', '');
            planeSet.effect = new Tw2Effect();
            if (hullSets[i]['skinned']) {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/skinned_planeglow.fx';
            }
            else {
                planeSet.effect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/planeglow.fx';
            }
            planeSet.effect.parameters['Layer1Map'] = new Tw2TextureParameter('Layer1Map', hullSets[i]['layer1MapResPath']);
            planeSet.effect.parameters['Layer2Map'] = new Tw2TextureParameter('Layer2Map', hullSets[i]['layer2MapResPath']);
            planeSet.effect.parameters['MaskMap'] = new Tw2TextureParameter('MaskMap', hullSets[i]['maskMapResPath']);
            planeSet.effect.parameters['PlaneData'] = new Tw2Vector4Parameter('PlaneData', _get(hullSets[i], 'planeData', [1, 0, 0, 0]));
            planeSet.effect.Initialize();

            var hullData = _get(hullSets[i], 'items', []);
            for (var j = 0; j &lt; hullData.length; ++j) {
                var item = new EvePlaneSetItem();
                _assignIfExists(item, hullData[j], 'groupIndex');
                _assignIfExists(item, hullData[j], 'name');
                _assignIfExists(item, hullData[j], 'position');
                _assignIfExists(item, hullData[j], 'rotation');
                _assignIfExists(item, hullData[j], 'scaling');
                _assignIfExists(item, hullData[j], 'color');
                quat4.set(_get(hullData[j], 'layer1Transform', [0, 0, 0, 0]), item.layer1Transform);
                _assignIfExists(item, hullData[j], 'layer1Scroll');
                quat4.set(_get(hullData[j], 'layer2Transform', [0, 0, 0, 0]), item.layer2Transform);
                _assignIfExists(item, hullData[j], 'layer2Scroll');
                item.boneIndex = _get(hullData[j], 'boneIndex', -1);
                item.maskAtlasID = _get(hullData[j], 'maskMapAtlasIndex', 0);

                var factionSet = factionSets['group' + _get(hullData[j], 'groupIndex', -1)];
                if (factionSet) {
                    quat4.set(_get(factionSet, 'color', [0, 0, 0, 0]), item.color);
                }
                planeSet.planes.push(item);
            }
            planeSet.Initialize();
            ship.planeSets.push(planeSet);
        }
    }

    function SetupBoosters(ship, hull, race) {
        if (!('booster' in hull)) {
            return;
        }
        var booster = new EveBoosterSet();
        var hullBooster = hull['booster'];
        var raceBooster = _get(race, 'booster', {});
        _assignIfExists(booster, raceBooster, 'glowScale');
        _assignIfExists(booster, raceBooster, 'glowColor');
        _assignIfExists(booster, raceBooster, 'warpGlowColor');
        _assignIfExists(booster, raceBooster, 'symHaloScale');
        _assignIfExists(booster, raceBooster, 'haloScaleX');
        _assignIfExists(booster, raceBooster, 'haloScaleY');
        _assignIfExists(booster, raceBooster, 'haloColor');
        _assignIfExists(booster, raceBooster, 'warpHalpColor');

        booster.effect = new Tw2Effect();
        booster.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterVolumetric.fx';
        booster.effect.parameters['NoiseFunction0'] = new Tw2FloatParameter('NoiseFunction0', _get(raceBooster.shape0, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed0'] = new Tw2FloatParameter('NoiseSpeed0', _get(raceBooster.shape0, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart0'] = new Tw2Vector4Parameter('NoiseAmplitudeStart0', _get(raceBooster.shape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd0'] = new Tw2Vector4Parameter('NoiseAmplitudeEnd0', _get(raceBooster.shape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency0'] = new Tw2Vector4Parameter('NoiseFrequency0', _get(raceBooster.shape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color0'] = new Tw2Vector4Parameter('Color0', _get(raceBooster.shape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['NoiseFunction1'] = new Tw2FloatParameter('NoiseFunction1', _get(raceBooster.shape1, 'noiseFunction', 0));
        booster.effect.parameters['NoiseSpeed1'] = new Tw2FloatParameter('NoiseSpeed1', _get(raceBooster.shape1, 'noiseSpeed', 0));
        booster.effect.parameters['NoiseAmplitudeStart1'] = new Tw2Vector4Parameter('NoiseAmplitudeStart1', _get(raceBooster.shape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseAmplitudeEnd1'] = new Tw2Vector4Parameter('NoiseAmplitudeEnd1', _get(raceBooster.shape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['NoiseFrequency1'] = new Tw2Vector4Parameter('NoiseFrequency1', _get(raceBooster.shape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['Color1'] = new Tw2Vector4Parameter('Color1', _get(raceBooster.shape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction0'] = new Tw2FloatParameter('WarpNoiseFunction0', _get(raceBooster.warpShape0, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed0'] = new Tw2FloatParameter('WarpNoiseSpeed0', _get(raceBooster.warpShape0, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart0'] = new Tw2Vector4Parameter('WarpNoiseAmplitudeStart0', _get(raceBooster.warpShape0, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd0'] = new Tw2Vector4Parameter('WarpNoiseAmplitudeEnd0', _get(raceBooster.warpShape0, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency0'] = new Tw2Vector4Parameter('WarpNoiseFrequency0', _get(raceBooster.warpShape0, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor0'] = new Tw2Vector4Parameter('WarpColor0', _get(raceBooster.warpShape0, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['WarpNoiseFunction1'] = new Tw2FloatParameter('WarpNoiseFunction1', _get(raceBooster.warpShape1, 'noiseFunction', 0));
        booster.effect.parameters['WarpNoiseSpeed1'] = new Tw2FloatParameter('WarpNoiseSpeed1', _get(raceBooster.warpShape1, 'noiseSpeed', 0));
        booster.effect.parameters['WarpNoiseAmplitudeStart1'] = new Tw2Vector4Parameter('WarpNoiseAmplitudeStart1', _get(raceBooster.warpShape1, 'noiseAmplitureStart', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseAmplitudeEnd1'] = new Tw2Vector4Parameter('WarpNoiseAmplitudeEnd1', _get(raceBooster.warpShape1, 'noiseAmplitureEnd', [0, 0, 0, 0]));
        booster.effect.parameters['WarpNoiseFrequency1'] = new Tw2Vector4Parameter('WarpNoiseFrequency1', _get(raceBooster.warpShape1, 'noiseFrequency', [0, 0, 0, 0]));
        booster.effect.parameters['WarpColor1'] = new Tw2Vector4Parameter('WarpColor1', _get(raceBooster.warpShape1, 'color', [0, 0, 0, 0]));

        booster.effect.parameters['ShapeAtlasSize'] = new Tw2Vector4Parameter('ShapeAtlasSize', [_get(raceBooster, 'shapeAtlasHeight', 0), _get(raceBooster, 'shapeAtlasCount', 0), 0, 0]);
        booster.effect.parameters['BoosterScale'] = new Tw2Vector4Parameter('BoosterScale', _get(raceBooster, 'scale', [1, 1, 1, 1]));

        booster.effect.parameters['ShapeMap'] = new Tw2TextureParameter('ShapeMap', raceBooster.shapeAtlasResPath);
        booster.effect.parameters['GradientMap0'] = new Tw2TextureParameter('GradientMap0', raceBooster.gradient0ResPath);
        booster.effect.parameters['GradientMap1'] = new Tw2TextureParameter('GradientMap1', raceBooster.gradient1ResPath);
        booster.effect.parameters['NoiseMap'] = new Tw2TextureParameter('ShapeMap', "res:/Texture/Global/noise32cube_volume.dds.0.png");

        booster.effect.Initialize();

        booster.glows = new EveSpriteSet(true);
        booster.glows.effect = new Tw2Effect();
        booster.glows.effect.effectFilePath = 'res:/Graphics/Effect/Managed/Space/Booster/BoosterGlowAnimated.fx';
        booster.glows.effect.parameters['DiffuseMap'] = new Tw2TextureParameter('DiffuseMap', 'res:/Texture/Particle/whitesharp.dds.0.png');
        booster.glows.effect.parameters['NoiseMap'] = new Tw2TextureParameter('NoiseMap', 'res:/Texture/global/noise.dds.0.png');
        booster.glows.effect.Initialize();

        var items = _get(hullBooster, 'items', []);
        for (var i = 0; i &lt; items.length; ++i) {
            var locator = new EveLocator();
            locator.name = 'locator_booster_' + (i + 1);
            if ('transform' in items[i]) {
                locator.transform = items[i].transform;
            }
            else {
                mat4.identity(locator.transform);
            }
            locator.atlasIndex0 = _get(items[i], 'atlasIndex0', 0);
            locator.atlasIndex1 = _get(items[i], 'atlasIndex1', 0);
            ship.locators.push(locator);
        }
        booster.Initialize();
        ship.boosters = booster;
    }

    function SetupLocators(ship, hull) {
        var hullLocators = _get(hull, 'locatorTurrets', []);
        for (var i = 0; i &lt; hullLocators.length; ++i) {
            var locator = new EveLocator();
            locator.name = hullLocators[i].name;
            if ('transform' in hullLocators[i]) {
                locator.transform = hullLocators[i].transform;
            }
            else {
                mat4.identity(locator.transform);
            }
            ship.locators.push(locator);
        }
    }

    function BindParticleEmitters(obj, curveSet, curve) {
        for (var i = 0; i &lt; obj.particleEmitters.length; ++i) {
            if ('rate' in obj.particleEmitters[i]) {
                var binding = new Tw2ValueBinding();
                binding.sourceObject = curve;
                binding.sourceAttribute = 'currentValue';
                binding.destinationObject = obj.particleEmitters[i];
                binding.destinationAttribute = 'rate';
                binding.Initialize();
                curveSet.bindings.push(binding);
            }
        }
        for (i = 0; i &lt; obj.children.length; ++i) {
            BindParticleEmitters(obj.children[i], curveSet, curve);
        }
    }

    function SetupChildren(ship, hull, curveSet, curves) {
        function onChildLoaded(child) {
            return function (obj) {
                if (obj.isEffectChild)
                {
                    ship.effectChildren.push(obj);
                }
                else
                {
                    ship.children.push(obj);
                }
                _assignIfExists(obj, child, 'translation');
                _assignIfExists(obj, child, 'rotation');
                _assignIfExists(obj, child, 'scaling');
                var id = _get(child, 'id', -1);
                if (id != -1 &amp;&amp; curves[id]) {
                    BindParticleEmitters(obj, curveSet, curves[id]);
                }
            };
        }
        var children = _get(hull, 'children', []);
        for (var i = 0; i &lt; children.length; ++i) {
            resMan.GetObject(children[i]['redFilePath'], onChildLoaded(children[i]));
        }
    }

    function SetupAnimations(ship, hull) {
        var id_curves = [];
        var curveSet = null;
        var animations = _get(hull, 'animations', []);
        for (var i = 0; i &lt; animations.length; ++i) {
            if (_get(animations[i], 'id', -1) != -1 &amp;&amp; (_get(animations[i], 'startRate', -1) != -1)) {
                if (!curveSet) {
                    curveSet = new Tw2CurveSet();
                }
                var curve = new Tw2ScalarCurve2();
                curve.keys.push(new Tw2ScalarKey2());
                curve.keys.push(new Tw2ScalarKey2());
                curve.keys[0].value = _get(animations[i], 'startRate', -1);
                curve.keys[1].time = 1;
                curve.keys[1].value = _get(animations[i], 'endRate', -1);
                curve.Initialize();
                curveSet.curves.push(curve);
                ship.curveSets.push(curveSet);
                id_curves[_get(animations[i], 'id', -1)] = curve;
            }
        }
        if (curveSet) {
            curveSet.Initialize();
        }
        return [curveSet, id_curves];
    }

    var dataLoading = false;
    var pendingLoads = [];

    function Build(dna) {
        var parts = dna.split(':');
        var commands = {};
        for (var i = 3; i &lt; parts.length; ++i)
        {
            var subparts = parts[i].split('?');
            commands[subparts[0]] = subparts[1].split(';');
        }
        var hull = data['hull'][parts[0]];
        var faction = data['faction'][parts[1]];
        var race = data['race'][parts[2]];
        var ship = new (_get(hull, 'buildClass', 0) == 2 ? EveSpaceObject : EveShip)();
        var pattern = SetupPattern(hull, race, commands);
        SetupMesh(ship, hull, faction, race, commands, pattern);
        SetupCustomMasks(ship, pattern);
        SetupDecals(ship, hull, faction);
        SetupSpriteSets(ship, hull, faction);
        SetupSpotlightSets(ship, hull, faction);
        SetupPlaneSets(ship, hull, faction);
        SetupBoosters(ship, hull, race);
        SetupLocators(ship, hull);
        var curves = SetupAnimations(ship, hull);
        SetupChildren(ship, hull, curves[0], curves[1]);
        SetupInstancedMeshes(ship, hull, faction, race, commands, pattern);

        ship.Initialize();
        return ship;
    }

    this.LoadData = function (callback) {
        if (data == null) {
            if (callback) {
                pendingLoads.push(callback);
            }
            if (!dataLoading) {
                spriteEffect = new Tw2Effect();
                spriteEffect.effectFilePath = 'res:/graphics/effect/managed/space/spaceobject/fx/blinkinglightspool.fx';
                spriteEffect.parameters['MainIntensity'] = new Tw2FloatParameter('MainIntensity', 1);
                spriteEffect.parameters['GradientMap'] = new Tw2TextureParameter('GradientMap', 'res:/texture/particle/whitesharp_gradient.dds.0.png');
                spriteEffect.Initialize();

                resMan.GetObject('res:/dx9/model/spaceobjectfactory/data.red', function (obj) {
                    data = obj;
                    for (var i = 0; i &lt; pendingLoads.length; ++i) {
                        pendingLoads[i]();
                    }
                    pendingLoads = [];
                });
                dataLoading = true;
            }
        }
        else {
            if (callback) {
                callback();
            }
        }
    };

    this.BuildFromDNA = function (dna, callback) {
        if (data == null) {
            this.LoadData(function () {
                var result = Build(dna);
                if (callback) {
                    callback(result);
                }
            });
        }
        else {
            var result = Build(dna);
            if (callback) {
                callback(result);
            }
        }
    };

    function GetTurretMaterialParameter(name, parentFaction, areaData) {
        var materialIdx = -1;
        for (var i = 0; i &lt; data['generic']['materialPrefixes'].length; ++i) {
            if (name.substr(0, data['generic']['materialPrefixes'][i].length) == data['generic']['materialPrefixes'][i]) {
                materialIdx = i;
                name = name.substr(data['generic']['materialPrefixes'][i].length);
            }
        }
        if (materialIdx != -1) {
            var turretMaterialIndex = _get(parentFaction, 'materialUsageMtl' + (materialIdx + 1), materialIdx);
            if (turretMaterialIndex >= 0 &amp;&amp; turretMaterialIndex &lt; data['generic']['materialPrefixes'].length) {
                name = data['generic']['materialPrefixes'][turretMaterialIndex] + name;
                if (name in areaData.parameters) {
                    return areaData.parameters[name];
                }
            }
        }
    }

    var zeroColor = [0, 0, 0, 0];

    function CombineTurretMaterial(name, parentValue, turretValue, overrideMethod) {
        switch (overrideMethod) {
            case 'overridable':
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'half_overridable':
                if (name.indexOf('GlowColor') >= 0) {
                    return turretValue ? turretValue : zeroColor;
                }
                return parentValue ? parentValue : turretValue ? turretValue : zeroColor;
            case 'not_overridable':
            case 'half_overridable_2':
                return turretValue ? turretValue : zeroColor;
        }
        return zeroColor;
    }

    function SetupTurretMaterial(turretSet, parentFactionName, turretFactionName) {
        var parentFaction = data['faction'][parentFactionName];
        var turretFaction = data['faction'][turretFactionName];
        var parentArea = null;
        if (parentFaction &amp;&amp; parentFaction.areas &amp;&amp; ('hull' in parentFaction.areas)) {
            parentArea = parentFaction.areas.hull;
        }
        var turretArea = null;
        if (turretFaction &amp;&amp; turretFaction.areas &amp;&amp; ('hull' in turretFaction.areas)) {
            turretArea = turretFaction.areas.hull;
        }
        if (!parentArea &amp;&amp; !turretArea) {
            return;
        }
        if (turretSet.turretEffect) {
            var params = turretSet.turretEffect.parameters;
            for (var i in params) {
                if (params.hasOwnProperty(i)) {
                    if (params[i].constructor.prototype != Tw2Vector4Parameter.prototype) {
                        continue;
                    }
                    var parentValue = null;
                    var turretValue = null;
                    if (parentArea) {
                        parentValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    if (turretArea) {
                        turretValue = GetTurretMaterialParameter(i, parentFaction, parentArea);
                    }
                    quat4.set(CombineTurretMaterial(i, parentValue, turretValue, turretSet.turretEffect.name), params[i].value);
                }
            }
            turretSet.turretEffect.BindParameters();
        }
    }

    this.SetupTurretMaterial = function (turretSet, parentFactionName, turretFactionName, callback) {
        if (data == null) {
            this.LoadData(function () {
                SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
                if (callback) {
                    callback();
                }
            });
        }
        else {
            SetupTurretMaterial(turretSet, parentFactionName, turretFactionName);
            if (callback) {
                callback();
            }
        }
    };

    function getDataKeys(name) {
        if (name !== 'all') {
            var names = {};
            for (var i in data[name]) {
                if (data[name].hasOwnProperty(i)) {
                    names[i] = data[name][i].description || '';
                }
            }
            return names;
        } else {
            return data
        }
    }

    this.GetHullNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('hull'));
       });
    };

    this.GetFactionNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('faction'));
       });
    };

    this.GetRaceNames = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('race'));
       });
    };
    
    this.GetSofData = function (callback) {
        this.LoadData(function () {
            callback(getDataKeys('all'));
        })
    };

    
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="EveBasicPerObjectData.html">EveBasicPerObjectData</a></li><li><a href="EveBasicPerObjectData_SetPerObjectDataToDevice.html">SetPerObjectDataToDevice</a></li><li><a href="EveBoosterBatch.html">EveBoosterBatch</a></li><li><a href="EveBoosterSet.html">EveBoosterSet</a></li><li><a href="EveBoosterSet_Add.html">Add</a></li><li><a href="EveBoosterSet_Update.html">Update</a></li><li><a href="EveChildBillboard.html">EveChildBillboard</a></li><li><a href="EveChildContainer.html">EveChildContainer</a></li><li><a href="EveChildExplosion.html">EveChildExplosion</a></li><li><a href="EveChildMesh.html">EveChildMesh</a></li><li><a href="EveChildParticleSystem.html">EveChildParticleSystem</a></li><li><a href="EveCurveLineSet.html">EveCurveLineSet</a></li><li><a href="EveEffectRoot.html">EveEffectRoot</a></li><li><a href="EveLensflare.html">EveLensflare</a></li><li><a href="EveLocator.html">EveLocator</a></li><li><a href="EveMeshOverlayEffect.html">EveMeshOverlayEffect</a></li><li><a href="EveMissile.html">EveMissile</a></li><li><a href="EveMissileWarhead.html">EveMissileWarhead</a></li><li><a href="EveOccluder.html">EveOccluder</a></li><li><a href="EvePlaneSet.html">EvePlaneSet</a></li><li><a href="EvePlaneSet_Render.html">Render</a></li><li><a href="EvePlaneSetBatch.html">EvePlaneSetBatch</a></li><li><a href="EvePlaneSetBatch_Commit.html">Commit</a></li><li><a href="EvePlaneSetItem.html">EvePlaneSetItem</a></li><li><a href="EvePlanet.html">EvePlanet</a></li><li><a href="EvePlanet_GetPlanetResources.html">GetPlanetResources</a></li><li><a href="EveShip.html">EveShip</a></li><li><a href="EveSpaceObject.html">EveSpaceObject</a></li><li><a href="EveSpaceObjectDecal.html">EveSpaceObjectDecal</a></li><li><a href="EveSpaceScene.html">EveSpaceScene</a></li><li><a href="EveSpotlightSet.html">EveSpotlightSet</a></li><li><a href="EveSpotlightSetBatch.html">EveSpotlightSetBatch</a></li><li><a href="EveSpotlightSetItem.html">EveSpotlightSetItem</a></li><li><a href="EveSpriteSet.html">EveSpriteSet</a></li><li><a href="EveSpriteSet_Add.html">Add</a></li><li><a href="EveSpriteSetBatch.html">EveSpriteSetBatch</a></li><li><a href="EveSpriteSetItem.html">EveSpriteSetItem</a></li><li><a href="EveStretch.html">EveStretch</a></li><li><a href="EveTransform.html">EveTransform</a></li><li><a href="EveTurretData.html">EveTurretData</a></li><li><a href="EveTurretSet.html">EveTurretSet</a></li><li><a href="EveTurretSet_UpdateViewDependentData.html">UpdateViewDependentData</a></li><li><a href="Tr2ParticleElement.html">Tr2ParticleElement</a></li><li><a href="Tw2Animation.html">Tw2Animation</a></li><li><a href="Tw2AnimationController_GetAnimation.html">GetAnimation</a></li><li><a href="Tw2AnimationController_GetPlayingAnimations.html">GetPlayingAnimations</a></li><li><a href="Tw2AnimationController_ResetAnimation.html">ResetAnimation</a></li><li><a href="Tw2BatchAccumulator.html">Tw2BatchAccumulator</a></li><li><a href="Tw2BinaryReader.html">Tw2BinaryReader</a></li><li><a href="Tw2BlendShapeData.html">Tw2BlendShapeData</a></li><li><a href="Tw2Bone.html">Tw2Bone</a></li><li><a href="Tw2ColorCurve.html">Tw2ColorCurve</a></li><li><a href="Tw2ColorCurve2.html">Tw2ColorCurve2</a></li><li><a href="Tw2ColorKey.html">Tw2ColorKey</a></li><li><a href="Tw2ColorKey2.html">Tw2ColorKey2</a></li><li><a href="Tw2ColorSequencer.html">Tw2ColorSequencer</a></li><li><a href="Tw2CurveSet.html">Tw2CurveSet</a></li><li><a href="Tw2Device.html">Tw2Device</a></li><li><a href="Tw2Device_SetStandardStates.html">SetStandardStates</a></li><li><a href="Tw2DynamicEmitter.html">Tw2DynamicEmitter</a></li><li><a href="Tw2Effect.html">Tw2Effect</a></li><li><a href="Tw2EffectRes.html">Tw2EffectRes</a></li><li><a href="Tw2EulerRotation.html">Tw2EulerRotation</a></li><li><a href="Tw2EventCurve.html">Tw2EventCurve</a></li><li><a href="Tw2EventKey.html">Tw2EventKey</a></li><li><a href="Tw2Float.html">Tw2Float</a></li><li><a href="Tw2FloatParameter.html">Tw2FloatParameter</a></li><li><a href="Tw2ForwardingRenderBatch.html">Tw2ForwardingRenderBatch</a></li><li><a href="Tw2Frustum.html">Tw2Frustum</a></li><li><a href="Tw2GeometryAnimation.html">Tw2GeometryAnimation</a></li><li><a href="Tw2GeometryBatch.html">Tw2GeometryBatch</a></li><li><a href="Tw2GeometryBone.html">Tw2GeometryBone</a></li><li><a href="Tw2GeometryCurve.html">Tw2GeometryCurve</a></li><li><a href="Tw2GeometryLineBatch.html">Tw2GeometryLineBatch</a></li><li><a href="Tw2GeometryMesh.html">Tw2GeometryMesh</a></li><li><a href="Tw2GeometryMeshArea.html">Tw2GeometryMeshArea</a></li><li><a href="Tw2GeometryMeshBinding.html">Tw2GeometryMeshBinding</a></li><li><a href="Tw2GeometryModel.html">Tw2GeometryModel</a></li><li><a href="Tw2GeometryModel_FindBoneByName.html">FindBoneByName</a></li><li><a href="Tw2GeometryRes.html">Tw2GeometryRes</a></li><li><a href="Tw2GeometrySkeleton.html">Tw2GeometrySkeleton</a></li><li><a href="Tw2GeometryTrackGroup.html">Tw2GeometryTrackGroup</a></li><li><a href="Tw2GeometryTransformTrack.html">Tw2GeometryTransformTrack</a></li><li><a href="Tw2InstancedMesh.html">Tw2InstancedMesh</a></li><li><a href="Tw2InstancedMeshBatch.html">Tw2InstancedMeshBatch</a></li><li><a href="Tw2LoadingObject.html">Tw2LoadingObject</a></li><li><a href="Tw2MatrixParameter.html">Tw2MatrixParameter</a></li><li><a href="Tw2MayaAnimationEngine.html">Tw2MayaAnimationEngine</a></li><li><a href="Tw2MayaEulerRotationCurve.html">Tw2MayaEulerRotationCurve</a></li><li><a href="Tw2MayaScalarCurve.html">Tw2MayaScalarCurve</a></li><li><a href="Tw2MayaVector3Curve.html">Tw2MayaVector3Curve</a></li><li><a href="Tw2Mesh.html">Tw2Mesh</a></li><li><a href="Tw2MeshArea.html">Tw2MeshArea</a></li><li><a href="Tw2MeshLineArea.html">Tw2MeshLineArea</a></li><li><a href="Tw2Model.html">Tw2Model</a></li><li><a href="Tw2MotherLode.html">Tw2MotherLode</a></li><li><a href="Tw2ObjectReader.html">Tw2ObjectReader</a></li><li><a href="Tw2ParticleAttractorForce.html">Tw2ParticleAttractorForce</a></li><li><a href="Tw2ParticleDirectForce.html">Tw2ParticleDirectForce</a></li><li><a href="Tw2ParticleDragForce.html">Tw2ParticleDragForce</a></li><li><a href="Tw2ParticleElementDeclaration.html">Tw2ParticleElementDeclaration</a></li><li><a href="Tw2ParticleFluidDragForce.html">Tw2ParticleFluidDragForce</a></li><li><a href="Tw2ParticleSpring.html">Tw2ParticleSpring</a></li><li><a href="Tw2ParticleSystem.html">Tw2ParticleSystem</a></li><li><a href="Tw2ParticleSystem_GetInstanceBuffer.html">GetInstanceBuffer</a></li><li><a href="Tw2ParticleTurbulenceForce.html">Tw2ParticleTurbulenceForce</a></li><li><a href="Tw2PerlinCurve.html">Tw2PerlinCurve</a></li><li><a href="Tw2PerObjectData.html">Tw2PerObjectData</a></li><li><a href="Tw2PerObjectData_SetPerObjectDataToDevice.html">SetPerObjectDataToDevice</a></li><li><a href="Tw2PostProcess.html">Tw2PostProcess</a></li><li><a href="Tw2QuaternionCurve.html">Tw2QuaternionCurve</a></li><li><a href="Tw2QuaternionKey.html">Tw2QuaternionKey</a></li><li><a href="Tw2QuaternionKey2.html">Tw2QuaternionKey2</a></li><li><a href="Tw2QuaternionSequencer.html">Tw2QuaternionSequencer</a></li><li><a href="Tw2RandomConstantCurve.html">Tw2RandomConstantCurve</a></li><li><a href="Tw2RandomIntegerAttributeGenerator.html">Tw2RandomIntegerAttributeGenerator</a></li><li><a href="Tw2RandomUniformAttributeGenerator.html">Tw2RandomUniformAttributeGenerator</a></li><li><a href="Tw2RawData.html">Tw2RawData</a></li><li><a href="Tw2RenderBatch.html">Tw2RenderBatch</a></li><li><a href="Tw2RenderTarget.html">Tw2RenderTarget</a></li><li><a href="Tw2ResMan.html">Tw2ResMan</a></li><li><a href="Tw2Resource.html">Tw2Resource</a></li><li><a href="Tw2RGBAScalarSequencer.html">Tw2RGBAScalarSequencer</a></li><li><a href="Tw2RigidOrientation.html">Tw2RigidOrientation</a></li><li><a href="Tw2RotationCurve.html">Tw2RotationCurve</a></li><li><a href="Tw2RuntimeInstanceData.html">Tw2RuntimeInstanceData</a></li><li><a href="Tw2RuntimeInstanceData_SetData.html">SetData</a></li><li><a href="Tw2RuntimeInstanceData_SetItemElement.html">SetItemElement</a></li><li><a href="Tw2RuntimeInstanceData_SetItemElementRef.html">SetItemElementRef</a></li><li><a href="Tw2SamplerOverride.html">Tw2SamplerOverride</a></li><li><a href="Tw2SamplerState.html">Tw2SamplerState</a></li><li><a href="Tw2ScalarCurve.html">Tw2ScalarCurve</a></li><li><a href="Tw2ScalarCurve2.html">Tw2ScalarCurve2</a></li><li><a href="Tw2ScalarKey.html">Tw2ScalarKey</a></li><li><a href="Tw2ScalarKey2.html">Tw2ScalarKey2</a></li><li><a href="Tw2ScalarSequencer.html">Tw2ScalarSequencer</a></li><li><a href="Tw2SineCurve.html">Tw2SineCurve</a></li><li><a href="Tw2SphereShapeAttributeGenerator.html">Tw2SphereShapeAttributeGenerator</a></li><li><a href="Tw2StaticEmitter.html">Tw2StaticEmitter</a></li><li><a href="Tw2TextureParameter.html">Tw2TextureParameter</a></li><li><a href="Tw2TextureParameter_SetTexturePath.html">SetTexturePath</a></li><li><a href="Tw2TextureRes.html">Tw2TextureRes</a></li><li><a href="Tw2TextureRes_Attach.html">Attach</a></li><li><a href="Tw2TextureRes_Bind.html">Bind</a></li><li><a href="Tw2TextureRes_Unload.html">Unload</a></li><li><a href="Tw2Torque.html">Tw2Torque</a></li><li><a href="Tw2Track.html">Tw2Track</a></li><li><a href="Tw2TrackGroup.html">Tw2TrackGroup</a></li><li><a href="Tw2TransformParameter.html">Tw2TransformParameter</a></li><li><a href="Tw2TransformParameter_Apply.html">Apply</a></li><li><a href="Tw2TransformTrack.html">Tw2TransformTrack</a></li><li><a href="Tw2ValueBinding.html">Tw2ValueBinding</a></li><li><a href="Tw2VariableParameter.html">Tw2VariableParameter</a></li><li><a href="Tw2VariableStore.html">Tw2VariableStore</a></li><li><a href="Tw2VariableStore_RegisterType.html">RegisterType</a></li><li><a href="Tw2VariableStore_RegisterVariable.html">RegisterVariable</a></li><li><a href="Tw2VariableStore_RegisterVariableWithType.html">RegisterVariableWithType</a></li><li><a href="Tw2Vector2Curve.html">Tw2Vector2Curve</a></li><li><a href="Tw2Vector2Key.html">Tw2Vector2Key</a></li><li><a href="Tw2Vector2Parameter.html">Tw2Vector2Parameter</a></li><li><a href="Tw2Vector3Curve.html">Tw2Vector3Curve</a></li><li><a href="Tw2Vector3Key.html">Tw2Vector3Key</a></li><li><a href="Tw2Vector3Parameter.html">Tw2Vector3Parameter</a></li><li><a href="Tw2Vector4Parameter.html">Tw2Vector4Parameter</a></li><li><a href="Tw2VectorCurve.html">Tw2VectorCurve</a></li><li><a href="Tw2VectorKey.html">Tw2VectorKey</a></li><li><a href="Tw2VectorSequencer.html">Tw2VectorSequencer</a></li><li><a href="Tw2VertexDeclaration.html">Tw2VertexDeclaration</a></li><li><a href="Tw2VertexElement.html">Tw2VertexElement</a></li><li><a href="Tw2WbgTrack.html">Tw2WbgTrack</a></li><li><a href="Tw2WbgTransformTrack.html">Tw2WbgTransformTrack</a></li><li><a href="Tw2XYZScalarSequencer.html">Tw2XYZScalarSequencer</a></li><li><a href="Tw2YPRSequencer.html">Tw2YPRSequencer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ag_horner1">ag_horner1</a></li><li><a href="global.html#ag_zeroin">ag_zeroin</a></li><li><a href="global.html#ag_zeroin2">ag_zeroin2</a></li><li><a href="global.html#emitter">emitter</a></li><li><a href="global.html#EveStation">EveStation</a></li><li><a href="global.html#EveTurretSetLocatorInfo">EveTurretSetLocatorInfo</a></li><li><a href="global.html#Inherit">Inherit</a></li><li><a href="global.html#Perlin_init">Perlin_init</a></li><li><a href="global.html#Perlin_noise1">Perlin_noise1</a></li><li><a href="global.html#PerlinNoise1D">PerlinNoise1D</a></li><li><a href="global.html#polyZeroes">polyZeroes</a></li><li><a href="global.html#Tw2AnimationController">Tw2AnimationController</a></li><li><a href="global.html#Tw2EventEmitter">Tw2EventEmitter</a></li><li><a href="global.html#vec3Hermite">vec3Hermite</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun May 07 2017 02:25:29 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
