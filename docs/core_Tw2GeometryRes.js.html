<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/Tw2GeometryRes.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/Tw2GeometryRes.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Tw2GeometryBatch
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect} effect
 * @inherit Tw2RenderBatch
 * @constructor
 */
function Tw2GeometryBatch()
{
    this._super.constructor.call(this);
    this.geometryRes = null;
    this.meshIx = 0;
    this.start = 0;
    this.count = 1;
    this.effect = null;
}

/**
 * Commits the Geometry Batch for rendering
 * @param {Tw2Effect} [overrideEffect]
 */
Tw2GeometryBatch.prototype.Commit = function(overrideEffect)
{
    var effect = typeof(overrideEffect) == 'undefined' ? this.effect : overrideEffect;
    if (this.geometryRes &amp;&amp; effect)
    {
        this.geometryRes.RenderAreas(this.meshIx, this.start, this.count, effect);
    }
};

Inherit(Tw2GeometryBatch, Tw2RenderBatch);


/**
 * Tw2GeometryLineBatch
 * @property {Tw2GeometryRes} geometryRes
 * @property {Number} meshIx
 * @property {Number} start
 * @property {Number} count
 * @property {Tw2Effect|null} effect
 * @inherit Tw2RenderBatch
 * @constructor
 */
function Tw2GeometryLineBatch()
{
    this._super.constructor.call(this);
    this.geometryRes = null;
    this.meshIx = 0;
    this.start = 0;
    this.count = 1;
    this.effect = null;
}

/**
 * Commits the Geometry Line Batch for rendering
 * @param {Tw2Effect} [overrideEffect]
 */
Tw2GeometryLineBatch.prototype.Commit = function(overrideEffect)
{
    var effect = typeof(overrideEffect) == 'undefined' ? this.effect : overrideEffect;
    if (this.geometryRes &amp;&amp; effect)
    {
        this.geometryRes.RenderLines(this.meshIx, this.start, this.count, effect);
    }
};

Inherit(Tw2GeometryLineBatch, Tw2RenderBatch);


/**
 * Tw2GeometryMeshArea
 * @property {string} name
 * @property {Number} start
 * @property {Number} count
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @constructor
 */
function Tw2GeometryMeshArea()
{
    this.name = '';
    this.start = 0;
    this.count = 0;
    this.minBounds = vec3.create();
    this.maxBounds = vec3.create();
    this.boundsSpherePosition = vec3.create();
    this.boundsSphereRadius = 0;
}


/**
 * Tw2GeometryMeshBinding
 * @property {Tw2GeometryMesh} mesh
 * @property {Array.&lt;Tw2GeometryBone>} bones
 * @constructor
 */
function Tw2GeometryMeshBinding()
{
    this.mesh = null;
    this.bones = [];
}


/**
 * Tw2GeometryModel
 * @property {string} name
 * @property {Array.&lt;Tw2GeometryMeshBinding>} meshBindings
 * @property {Tw2GeometrySkeleton} skeleton
 * @constructor
 */
function Tw2GeometryModel()
{
    this.name = '';
    this.meshBindings = [];
    this.skeleton = null;
}

/**
 * Finds a bone by it's name
 * @param {string} name
 * @returns {Tw2GeometryBone|null}
 * @constructor
 */
Tw2GeometryModel.prototype.FindBoneByName = function(name)
{
    if (this.skeleton == null)
    {
        return null;
    }
    for (var b = 0; b &lt; this.skeleton.bones.length; ++b)
    {
        if (this.skeleton.bones[b].name == name)
        {
            return this.skeleton.bones[b];
        }
    }
    return null;
};


/**
 * Tw2GeometrySkeleton
 * @property {Array.&lt;Tw2GeometryBone>} bones
 * @constructor
 */
function Tw2GeometrySkeleton()
{
    this.bones = [];
}


/**
 * Tw2GeometryBone
 * @property {string} name
 * @property {Number} parentIndex
 * @property {vec3} position
 * @property {quat4} orientation
 * @property {mat3} scaleShear
 * @property {mat4} localTransform
 * @property {mat4} worldTransform
 * @property {mat4} worldTransformInv
 * @constructor
 */
function Tw2GeometryBone()
{
    this.name = '';
    this.parentIndex = -1;
    this.position = vec3.create();
    this.orientation = quat4.create();
    this.scaleShear = mat3.create();
    this.localTransform = mat4.create();
    this.worldTransform = mat4.create();
    this.worldTransformInv = mat4.create();
}

/**
 * Updates the Bone's transform
 * @returns {mat4}
 */
Tw2GeometryBone.prototype.UpdateTransform = function()
{
    mat3.toMat4(this.scaleShear, this.localTransform);
    mat4.multiply(this.localTransform, mat4.transpose(quat4.toMat4(quat4.normalize(this.orientation))));
    //mat4.translate(this.localTransform, this.position);
    this.localTransform[12] = this.position[0];
    this.localTransform[13] = this.position[1];
    this.localTransform[14] = this.position[2];
    return this.localTransform;
};


/**
 * Tw2GeometryAnimation
 * @property {string} name
 * @property {Number} duration
 * @property {Array.&lt;Tw2GeometryTrackGroup>} trackGroups
 * @constructor
 */
function Tw2GeometryAnimation()
{
    this.name = '';
    this.duration = 0;
    this.trackGroups = [];
}


/**
 * Tw2GeometryTrackGroup
 * @property {string} name
 * @property {Tw2GeometryModel} model
 * @property {Array.&lt;Tw2GeometryTransformTrack>} transformTracks
 * @constructor
 */
function Tw2GeometryTrackGroup()
{
    this.name = '';
    this.model = null;
    this.transformTracks = [];
}


/**
 *
 * @property {string} name
 * @property {Tw2GeometryCurve} position
 * @property {Tw2GeometryCurve} orientation
 * @property scaleShear
 * @constructor
 */
function Tw2GeometryTransformTrack()
{
    this.name = '';
    this.position = null;
    this.orientation = null;
    this.scaleShear = null;
}


/**
 * Tw2GeometryCurve
 * @property {Number} dimension
 * @property {Number} degree
 * @property {Float32Array} knots
 * @property {Float32Array} controls
 * @constructor
 */
function Tw2GeometryCurve()
{
    this.dimension = 0;
    this.degree = 0;
    this.knots = null;
    this.controls = null;
}


/**
 * Tw2BlendShapeData
 * @property {String} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array} buffers
 * @property indexes
 * @property weightProxy
 * @constructor
 */
function Tw2BlendShapeData()
{
    this.name = '';
    this.declaration = new Tw2VertexDeclaration();
    this.buffers = [];
    this.indexes = null;
    this.weightProxy = null;
}


/**
 * Tw2GeometryMesh
 * @property {string} name
 * @property {Tw2VertexDeclaration} declaration
 * @property {Array.&lt;Tw2GeometryMeshArea>} areas
 * @property {WebGLBuffer} buffer
 * @property {Number} bufferLength
 * @property bufferData
 * @property {WebGLBuffer} indexes
 * @property indexData
 * @property {Number} indexType
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @property {Array} bones
 * @property {Array.&lt;string>} boneBindings
 * @constructor
 */
function Tw2GeometryMesh()
{
    this.name = '';
    this.declaration = new Tw2VertexDeclaration();
    this.areas = [];
    this.buffer = null;
    this.bufferLength = 0;
    this.bufferData = null;
    this.indexes = null;
    this.indexData = null;
    this.indexType = 0;
    this.minBounds = vec3.create();
    this.maxBounds = vec3.create();
    this.boundsSpherePosition = vec3.create();
    this.boundsSphereRadius = 0;
    this.bones = [];
    this.boneBindings = [];
}


/**
 * Tw2GeometryRes
 * @property {Array} meshes
 * @property {vec3} minBounds
 * @property {vec3} maxBounds
 * @property {vec3} boundsSpherePosition
 * @property {Number} boundsSphereRadius
 * @property {Array} models
 * @property {Array} animations
 * @property {Boolean} systemMirror
 * @inherit Tw2Resource
 * @constructor
 */
function Tw2GeometryRes()
{
    this._super.constructor.call(this);
    this.meshes = [];
    this.minBounds = vec3.create();
    this.maxBounds = vec3.create();
    this.boundsSpherePosition = vec3.create();
    this.boundsSphereRadius = 0;
    this.models = [];
    this.animations = [];
    this.systemMirror = resMan.systemMirror;
}

/**
 * Request Response Type
 * @type {string}
 */
Tw2GeometryRes.prototype.requestResponseType = 'arraybuffer';

/**
 * GetInstanceBuffer
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceBuffer = function(meshIndex)
{
    return meshIndex &lt; this.meshes.length ? this.meshes[meshIndex].buffer : undefined;
};

/**
 * GetInstanceDeclaration
 * @param {Number} meshIndex
 * @returns {Tw2VertexDeclaration}
 */
Tw2GeometryRes.prototype.GetInstanceDeclaration = function(meshIndex)
{
    return this.meshes[meshIndex].declaration;
};

/**
 * GetInstanceStride
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceStride = function(meshIndex)
{
    return this.meshes[meshIndex].declaration.stride;
};

/**
 * GetInstanceCount
 * @param {Number} meshIndex
 * @returns {*}
 */
Tw2GeometryRes.prototype.GetInstanceCount = function(meshIndex)
{
    return this.meshes[meshIndex].bufferLength * 4 / this.meshes[meshIndex].declaration.stride;
};

/**
 * Prepare
 * @param data
 */
Tw2GeometryRes.prototype.Prepare = function(data)
{
    var reader = new Tw2BinaryReader(new Uint8Array(data));
    var self = this;

    /**
     * ReadVertexBuffer
     * @param declaration
     * @returns {Float32Array}
     * @private
     */
    function ReadVertexBuffer(declaration)
    {
        var declCount = reader.ReadUInt8();
        var vertexSize = 0;
        var declIx, i;
        for (declIx = 0; declIx &lt; declCount; ++declIx)
        {
            var element = new Tw2VertexElement();
            element.usage = reader.ReadUInt8();
            element.usageIndex = reader.ReadUInt8();
            element.fileType = reader.ReadUInt8();
            element.type = device.gl.FLOAT;
            element.elements = (element.fileType >> 5) + 1;
            element.offset = vertexSize * 4;
            declaration.elements[declIx] = element;
            vertexSize += element.elements;
        }
        declaration.RebuildHash();
        declaration.stride = vertexSize * 4;
        var vertexCount = reader.ReadUInt32();
        if (vertexCount == 0)
        {
            return null;
        }
        var buffer = new Float32Array(vertexSize * vertexCount);
        var index = 0;
        for (var vtxIx = 0; vtxIx &lt; vertexCount; ++vtxIx)
        {
            for (declIx = 0; declIx &lt; declCount; ++declIx)
            {
                var el = declaration.elements[declIx];
                switch (el.fileType &amp; 0xf)
                {
                    case 0:
                        if ((el.fileType &amp; 0x10))
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadInt8() / 127.0;
                            }
                        }
                        else
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadInt8();
                            }
                        }
                        break;

                    case 1:
                        if ((el.fileType &amp; 0x10))
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadInt8() / 32767.0;
                            }
                        }
                        else
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadInt16();
                            }
                        }
                        break;

                    case 2:
                        for (i = 0; i &lt; el.elements; ++i)
                        {
                            buffer[index++] = reader.ReadInt32();
                        }
                        break;

                    case 3:
                        for (i = 0; i &lt; el.elements; ++i)
                        {
                            buffer[index++] = reader.ReadFloat16();
                        }
                        break;

                    case 4:
                        for (i = 0; i &lt; el.elements; ++i)
                        {
                            buffer[index++] = reader.ReadFloat32();
                        }
                        break;

                    case 8:
                        if ((el.fileType &amp; 0x10))
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadUInt8() / 255.0;
                            }
                        }
                        else
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadUInt8();
                            }
                        }
                        break;

                    case 9:
                        if ((el.fileType &amp; 0x10))
                        {
                            for (i = 0; i &lt; declaration.elements[declIx].elements; ++i)
                            {
                                buffer[index++] = reader.ReadUInt8() / 65535.0;
                            }
                        }
                        else
                        {
                            for (i = 0; i &lt; el.elements; ++i)
                            {
                                buffer[index++] = reader.ReadUInt16();
                            }
                        }
                        break;

                    case 10:
                        for (i = 0; i &lt; el.elements; ++i)
                        {
                            buffer[index++] = reader.ReadUInt32();
                        }
                        break;

                    default:
                        emitter.log('res.error',
                        {
                            log: 'error',
                            src: ['Tw2GeometryRes', 'ReadVertexBuffer'],
                            msg: 'Error loading wbg data',
                            path: self.path,
                            type: 'geometry.filetype',
                            value: el.fileType &amp; 0xf
                        });
                        throw 1;
                }
            }
        }
        return buffer;
    }

    /**
     * ReadIndexBuffer
     * @returns {Uint16Array|Uint32Array}
     * @private
     */
    function ReadIndexBuffer()
    {
        var ibType = reader.ReadUInt8();
        var indexCount = reader.ReadUInt32();
        var indexes, i;
        if (ibType == 0)
        {
            indexes = new Uint16Array(indexCount);
            for (i = 0; i &lt; indexCount; ++i)
            {
                indexes[i] = reader.ReadUInt16();
            }
            return indexes;
        }
        else
        {
            indexes = new Uint32Array(indexCount);
            for (i = 0; i &lt; indexCount; ++i)
            {
                indexes[i] = reader.ReadUInt32();
            }
            return indexes;
        }
    }

    /* var fileVersion = */
    reader.ReadUInt8();
    var meshCount = reader.ReadUInt8();
    for (var meshIx = 0; meshIx &lt; meshCount; ++meshIx)
    {
        var mesh = new Tw2GeometryMesh();
        mesh.name = reader.ReadString();

        var buffer = ReadVertexBuffer(mesh.declaration);
        var i, j, k;
        if (buffer)
        {
            mesh.bufferLength = buffer.length;
            mesh.buffer = device.gl.createBuffer();
            device.gl.bindBuffer(device.gl.ARRAY_BUFFER, mesh.buffer);
            device.gl.bufferData(device.gl.ARRAY_BUFFER, buffer, device.gl.STATIC_DRAW);
        }
        else
        {
            mesh.buffer = null;
        }

        var indexes = ReadIndexBuffer();
        if (indexes)
        {
            mesh.indexes = device.gl.createBuffer();
            mesh.indexType = indexes.BYTES_PER_ELEMENT == 2 ? device.gl.UNSIGNED_SHORT : device.gl.UNSIGNED_INT;
            device.gl.bindBuffer(device.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);
            device.gl.bufferData(device.gl.ELEMENT_ARRAY_BUFFER, indexes, device.gl.STATIC_DRAW);
        }
        else
        {
            mesh.indexes = null;
        }

        var areaCount = reader.ReadUInt8();
        for (i = 0; i &lt; areaCount; ++i)
        {
            mesh.areas[i] = new Tw2GeometryMeshArea();
            mesh.areas[i].name = reader.ReadString();
            mesh.areas[i].start = reader.ReadUInt32() * indexes.BYTES_PER_ELEMENT;
            mesh.areas[i].count = reader.ReadUInt32() * 3;
            mesh.areas[i].minBounds = vec3.create([reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()]);
            mesh.areas[i].maxBounds = vec3.create([reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()]);
        }

        var boneBindingCount = reader.ReadUInt8();
        mesh.boneBindings = [];
        for (i = 0; i &lt; boneBindingCount; ++i)
        {
            mesh.boneBindings[i] = reader.ReadString();
        }

        var annotationSetCount = reader.ReadUInt16();
        if (annotationSetCount || this.systemMirror)
        {
            mesh.bufferData = buffer;
            mesh.indexData = indexes;
        }
        if (annotationSetCount)
        {
            mesh.blendShapes = [];
            for (i = 0; i &lt; annotationSetCount; ++i)
            {
                mesh.blendShapes[i] = new Tw2BlendShapeData();
                mesh.blendShapes[i].name = reader.ReadString();
                mesh.blendShapes[i].buffer = ReadVertexBuffer(mesh.blendShapes[i].declaration);
                mesh.blendShapes[i].indexes = ReadIndexBuffer();
            }
        }
        this.meshes[meshIx] = mesh;
    }

    var modelCount = reader.ReadUInt8();
    for (var modelIx = 0; modelIx &lt; modelCount; ++modelIx)
    {
        var model = new Tw2GeometryModel();
        model.name = reader.ReadString();

        model.skeleton = new Tw2GeometrySkeleton();
        var boneCount = reader.ReadUInt8();
        for (j = 0; j &lt; boneCount; ++j)
        {
            var bone = new Tw2GeometryBone();
            bone.name = reader.ReadString();
            var flags = reader.ReadUInt8();
            bone.parentIndex = reader.ReadUInt8();
            if (bone.parentIndex == 255)
            {
                bone.parentIndex = -1;
            }
            if ((flags &amp; 1))
            {
                vec3.set([reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()], bone.position);
            }
            else
            {
                vec3.set([0, 0, 0], bone.position);
            }
            if ((flags &amp; 2))
            {
                quat4.set([reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()], bone.orientation);
            }
            else
            {
                quat4.set([0, 0, 0, 1], bone.orientation);
            }
            if ((flags &amp; 4))
            {
                for (k = 0; k &lt; 9; ++k)
                {
                    bone.scaleShear[k] = reader.ReadFloat32();
                }
            }
            else
            {
                mat3.identity(bone.scaleShear);
            }
            model.skeleton.bones[j] = bone;
        }
        for (j = 0; j &lt; model.skeleton.bones.length; ++j)
        {
            model.skeleton.bones[j].UpdateTransform();
            if (model.skeleton.bones[j].parentIndex != -1)
            {
                mat4.multiply(model.skeleton.bones[model.skeleton.bones[j].parentIndex].worldTransform, model.skeleton.bones[j].localTransform, model.skeleton.bones[j].worldTransform);
            }
            else
            {
                mat4.set(model.skeleton.bones[j].localTransform, model.skeleton.bones[j].worldTransform);
            }
            mat4.inverse(model.skeleton.bones[j].worldTransform, model.skeleton.bones[j].worldTransformInv);
        }

        var meshBindingCount = reader.ReadUInt8();
        for (j = 0; j &lt; meshBindingCount; ++j)
        {
            mesh = reader.ReadUInt8();
            if (mesh &lt; this.meshes.length)
            {
                Tw2GeometryRes.BindMeshToModel(this.meshes[mesh], model);
            }
        }
        this.models[this.models.length] = model;
    }

    /**
     * ReadCurve
     * @returns {Tw2GeometryCurve}
     * @private
     */
    function ReadCurve()
    {
        var type = reader.ReadUInt8();
        if (type == 0)
        {
            return null;
        }
        var dimension = reader.ReadUInt8();
        var curve = new Tw2GeometryCurve();
        curve.dimension = dimension;
        curve.degree = reader.ReadUInt8();
        var knotCount = reader.ReadUInt32();
        curve.knots = new Float32Array(knotCount);
        for (var i = 0; i &lt; knotCount; ++i)
        {
            curve.knots[i] = reader.ReadFloat32();
        }
        var controlCount = reader.ReadUInt32();
        curve.controls = new Float32Array(controlCount);
        for (i = 0; i &lt; controlCount; ++i)
        {
            curve.controls[i] = reader.ReadFloat32();
        }
        return curve;
    }

    var animationCount = reader.ReadUInt8();
    for (i = 0; i &lt; animationCount; ++i)
    {
        var animation = new Tw2GeometryAnimation();
        animation.name = reader.ReadString();
        animation.duration = reader.ReadFloat32();
        var groupCount = reader.ReadUInt8();
        for (j = 0; j &lt; groupCount; ++j)
        {
            var group = new Tw2GeometryTrackGroup();
            group.name = reader.ReadString();
            for (var m = 0; m &lt; this.models.length; ++m)
            {
                if (this.models[m].name == group.name)
                {
                    group.model = this.models[m];
                    break;
                }
            }
            var transformTrackCount = reader.ReadUInt8();
            for (k = 0; k &lt; transformTrackCount; ++k)
            {
                var track = new Tw2GeometryTransformTrack();
                track.name = reader.ReadString();
                track.orientation = ReadCurve();
                track.position = ReadCurve();
                track.scaleShear = ReadCurve();
                if (track.orientation)
                {
                    var lastX = 0;
                    var lastY = 0;
                    var lastZ = 0;
                    var lastW = 0;
                    for (var n = 0; n &lt; track.orientation.controls.length; n += 4)
                    {
                        var x = track.orientation.controls[n];
                        var y = track.orientation.controls[n + 1];
                        var z = track.orientation.controls[n + 2];
                        var w = track.orientation.controls[n + 3];
                        if (lastX * x + lastY * y + lastZ * z + lastW * w &lt; 0)
                        {
                            track.orientation.controls[n] = -x;
                            track.orientation.controls[n + 1] = -y;
                            track.orientation.controls[n + 2] = -z;
                            track.orientation.controls[n + 3] = -w;
                        }
                        lastX = x;
                        lastY = y;
                        lastZ = z;
                        lastW = w;
                    }
                }
                group.transformTracks[group.transformTracks.length] = track;
            }
            animation.trackGroups[animation.trackGroups.length] = group;
        }
        this.animations[this.animations.length] = animation;
    }
    this.PrepareFinished(true);
};

/**
 * BindMeshToModel
 * @param {Tw2GeometryMesh} mesh
 * @param {Tw2GeometryModel} model
 */
Tw2GeometryRes.BindMeshToModel = function(mesh, model)
{
    var binding = new Tw2GeometryMeshBinding();
    binding.mesh = mesh;
    for (var b = 0; b &lt; binding.mesh.boneBindings.length; ++b)
    {
        var name = binding.mesh.boneBindings[b];
        var bone = model.FindBoneByName(name);
        if (bone == null)
        {
            emitter.log('res.error',
            {
                log: 'error',
                src: ['Tw2GeometryRes', 'BindMeshToModel'],
                msg: 'Mesh has invalid bone name for model',
                path: this.path,
                type: 'geometry.invalidbone',
                data:
                {
                    mesh: binding.mesh.name,
                    bone: name,
                    model: model.name
                }
            });
        }
        else
        {
            binding.bones[binding.bones.length] = bone;
        }
    }
    model.meshBindings[model.meshBindings.length] = binding;
};

/**
 * RenderAreasInstanced
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param instanceVB
 * @param instanceDecl
 * @param instanceStride
 * @param instanceCount
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderAreasInstanced = function(meshIx, start, count, effect, instanceVB, instanceDecl, instanceStride, instanceCount)
{
    this.KeepAlive();
    if (!this._isGood)
    {
        return false;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood)
    {
        return false;
    }
    var d = device;
    var mesh = this.meshes[meshIx];
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass &lt; passCount; ++pass)
    {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (passInput.elements.length == 0)
        {
            continue;
        }
        d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
        mesh.declaration.SetPartialDeclaration(passInput, mesh.declaration.stride);
        d.gl.bindBuffer(d.gl.ARRAY_BUFFER, instanceVB);
        var resetData = instanceDecl.SetPartialDeclaration(passInput, instanceStride, 8, 1);
        d.ApplyShadowState();

        for (i = 0; i &lt; count; ++i)
        {
            if (i + start &lt; mesh.areas.length)
            {
                area = mesh.areas[i + start];
                var areaStart = area.start;
                var acount = area.count;
                while (i + 1 &lt; count)
                {
                    area = mesh.areas[i + 1 + start];
                    if (area.start != areaStart + acount * 2)
                    {
                        break;
                    }
                    acount += area.count;
                    ++i;
                }
                d.instancedArrays.drawElementsInstancedANGLE(d.gl.TRIANGLES, acount, mesh.indexType, areaStart, instanceCount);
            }
        }
        instanceDecl.ResetInstanceDivisors(resetData);
    }
    return true;
};

/**
 * RenderAreas
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param {callback} cb - callback[pass, drawElements]
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderAreas = function(meshIx, start, count, effect, cb)
{
    this.KeepAlive();
    if (!this._isGood)
    {
        return false;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood)
    {
        return false;
    }
    var d = device;
    var mesh = this.meshes[meshIx] || this.meshes[0];
    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass &lt; passCount; ++pass)
    {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride))
        {
            emitter.log('res.error',
            {
                log: 'error',
                src: ['Tw2GeometryRes', 'RenderLines'],
                msg: 'Error binding mesh to effect',
                path: this.path,
                type: 'geometry.meshbind',
                data:
                {
                    pass: pass,
                    passInput: passInput,
                    meshStride: mesh.declaration.stride
                }
            });
            return false;
        }
        d.ApplyShadowState();

        if (typeof(cb) != 'undefined')
        {
            var drawElements = [];
            for (i = 0; i &lt; count; ++i)
            {
                if (i + start &lt; mesh.areas.length)
                {
                    area = mesh.areas[i + start];
                    drawElements.push([d.gl.TRIANGLES, area.count, mesh.indexType, area.start]);
                }
            }
            cb(pass, drawElements);
        }
        else
        {
            for (i = 0; i &lt; count; ++i)
            {
                if (i + start &lt; mesh.areas.length)
                {
                    area = mesh.areas[i + start];
                    var areaStart = area.start;
                    var acount = area.count;
                    while (i + 1 &lt; count)
                    {
                        area = mesh.areas[i + 1 + start];
                        if (area.start != areaStart + acount * 2)
                        {
                            break;
                        }
                        acount += area.count;
                        ++i;
                    }
                    d.gl.drawElements(d.gl.TRIANGLES, acount, mesh.indexType, areaStart);
                }
            }
        }
    }
    return true;
};

/**
 * RenderLines
 * @param {Number} meshIx
 * @param {Number} start
 * @param {Number} count
 * @param {Tw2Effect} effect
 * @param {function} cb - callback[pass, drawElements]
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderLines = function(meshIx, start, count, effect, cb)
{
    this.KeepAlive();
    if (!this._isGood)
    {
        return false;
    }
    var effectRes = effect.GetEffectRes();
    if (!effectRes._isGood)
    {
        return false;
    }
    if (meshIx >= this.meshes.length)
    {
        return false;
    }
    var d = device;
    var mesh = this.meshes[meshIx];
    d.gl.bindBuffer(d.gl.ARRAY_BUFFER, mesh.buffer);
    d.gl.bindBuffer(d.gl.ELEMENT_ARRAY_BUFFER, mesh.indexes);

    var passCount = effect.GetPassCount();
    var i, area;
    for (var pass = 0; pass &lt; passCount; ++pass)
    {
        effect.ApplyPass(pass);
        var passInput = effect.GetPassInput(pass);
        if (!mesh.declaration.SetDeclaration(passInput, mesh.declaration.stride))
        {
            emitter.log('res.error',
            {
                log: 'error',
                src: ['Tw2GeometryRes', 'RenderLines'],
                msg: 'Error binding mesh to effect',
                path: this.path,
                type: 'geometry.meshbind',
                data:
                {
                    pass: pass,
                    passInput: passInput,
                    meshStride: mesh.declaration.stride
                }
            });
            return false;
        }

        d.ApplyShadowState();

        if (typeof(cb) != 'undefined')
        {
            var drawElements = [];
            for (i = 0; i &lt; count; ++i)
            {
                if (i + start &lt; mesh.areas.length)
                {
                    area = mesh.areas[i + start];
                    drawElements.push([d.gl.LINES, area.count, mesh.indexType, area.start]);
                }
            }
            cb(pass, drawElements);
        }
        else
        {
            for (i = 0; i &lt; count; ++i)
            {
                if (i + start &lt; mesh.areas.length)
                {
                    area = mesh.areas[i + start];
                    var areaStart = area.start;
                    var acount = area.count;
                    while (i + 1 &lt; count)
                    {
                        area = mesh.areas[i + 1 + start];
                        if (area.start != areaStart + acount * 2)
                        {
                            break;
                        }
                        acount += area.count;
                        ++i;
                    }
                    d.gl.drawElements(d.gl.LINES, acount, mesh.indexType, areaStart);
                }
            }
        }
    }
    return true;
};

/**
 * RenderDebugInfo
 * @param {function} debugHelper
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.RenderDebugInfo = function(debugHelper)
{
    if (!this.IsGood())
    {
        return false;
    }
    for (var i = 0; i &lt; this.models.length; ++i)
    {
        if (this.models[i].skeleton)
        {
            for (var j = 0; j &lt; this.models[i].skeleton.bones.length; ++j)
            {
                var b0 = this.models[i].skeleton.bones[j];
                if (b0.parentIndex >= 0)
                {
                    var b1 = this.models[i].skeleton.bones[b0.parentIndex];
                    debugHelper.AddLine(
                        [b0.worldTransform[12], b0.worldTransform[13], b0.worldTransform[14]], [b1.worldTransform[12], b1.worldTransform[13], b1.worldTransform[14]], [0, 0.7, 0, 1], [0, 0.7, 0, 1]);
                }
            }
        }
    }
};

/**
 * Unloads webgl and javascript resources
 * @returns {Boolean}
 */
Tw2GeometryRes.prototype.Unload = function()
{
    for (var i = 0; i &lt; this.meshes.length; ++i)
    {
        if (this.meshes[i].buffer)
        {
            device.gl.deleteBuffer(this.meshes[i].buffer);
            this.meshes[i].buffer = null;
        }
        if (this.meshes[i].indexes)
        {
            device.gl.deleteBuffer(this.meshes[i].indexes);
            this.meshes[i].indexes = null;
        }
    }
    this._isPurged = true;
    this._isGood = false;
    return true;
};

Inherit(Tw2GeometryRes, Tw2Resource);

// Register wgb constructor
resMan.RegisterExtension('wbg', Tw2GeometryRes);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="EveBasicPerObjectData.html">EveBasicPerObjectData</a></li><li><a href="EveBasicPerObjectData_SetPerObjectDataToDevice.html">SetPerObjectDataToDevice</a></li><li><a href="EveBoosterBatch.html">EveBoosterBatch</a></li><li><a href="EveBoosterSet.html">EveBoosterSet</a></li><li><a href="EveBoosterSet_Add.html">Add</a></li><li><a href="EveBoosterSet_Update.html">Update</a></li><li><a href="EveChildBillboard.html">EveChildBillboard</a></li><li><a href="EveChildContainer.html">EveChildContainer</a></li><li><a href="EveChildExplosion.html">EveChildExplosion</a></li><li><a href="EveChildMesh.html">EveChildMesh</a></li><li><a href="EveChildParticleSystem.html">EveChildParticleSystem</a></li><li><a href="EveCurveLineSet.html">EveCurveLineSet</a></li><li><a href="EveEffectRoot.html">EveEffectRoot</a></li><li><a href="EveLensflare.html">EveLensflare</a></li><li><a href="EveLocator.html">EveLocator</a></li><li><a href="EveMeshOverlayEffect.html">EveMeshOverlayEffect</a></li><li><a href="EveMissile.html">EveMissile</a></li><li><a href="EveMissileWarhead.html">EveMissileWarhead</a></li><li><a href="EveOccluder.html">EveOccluder</a></li><li><a href="EvePlaneSet.html">EvePlaneSet</a></li><li><a href="EvePlaneSet_Render.html">Render</a></li><li><a href="EvePlaneSetBatch.html">EvePlaneSetBatch</a></li><li><a href="EvePlaneSetBatch_Commit.html">Commit</a></li><li><a href="EvePlaneSetItem.html">EvePlaneSetItem</a></li><li><a href="EvePlanet.html">EvePlanet</a></li><li><a href="EvePlanet_GetPlanetResources.html">GetPlanetResources</a></li><li><a href="EveShip.html">EveShip</a></li><li><a href="EveSpaceObject.html">EveSpaceObject</a></li><li><a href="EveSpaceObjectDecal.html">EveSpaceObjectDecal</a></li><li><a href="EveSpaceScene.html">EveSpaceScene</a></li><li><a href="EveSpotlightSet.html">EveSpotlightSet</a></li><li><a href="EveSpotlightSetBatch.html">EveSpotlightSetBatch</a></li><li><a href="EveSpotlightSetItem.html">EveSpotlightSetItem</a></li><li><a href="EveSpriteSet.html">EveSpriteSet</a></li><li><a href="EveSpriteSet_Add.html">Add</a></li><li><a href="EveSpriteSetBatch.html">EveSpriteSetBatch</a></li><li><a href="EveSpriteSetItem.html">EveSpriteSetItem</a></li><li><a href="EveStretch.html">EveStretch</a></li><li><a href="EveTransform.html">EveTransform</a></li><li><a href="EveTurretData.html">EveTurretData</a></li><li><a href="EveTurretSet.html">EveTurretSet</a></li><li><a href="EveTurretSet_UpdateViewDependentData.html">UpdateViewDependentData</a></li><li><a href="Tr2ParticleElement.html">Tr2ParticleElement</a></li><li><a href="Tw2Animation.html">Tw2Animation</a></li><li><a href="Tw2AnimationController_GetAnimation.html">GetAnimation</a></li><li><a href="Tw2AnimationController_GetPlayingAnimations.html">GetPlayingAnimations</a></li><li><a href="Tw2AnimationController_ResetAnimation.html">ResetAnimation</a></li><li><a href="Tw2BatchAccumulator.html">Tw2BatchAccumulator</a></li><li><a href="Tw2BinaryReader.html">Tw2BinaryReader</a></li><li><a href="Tw2BlendShapeData.html">Tw2BlendShapeData</a></li><li><a href="Tw2Bone.html">Tw2Bone</a></li><li><a href="Tw2ColorCurve.html">Tw2ColorCurve</a></li><li><a href="Tw2ColorCurve2.html">Tw2ColorCurve2</a></li><li><a href="Tw2ColorKey.html">Tw2ColorKey</a></li><li><a href="Tw2ColorKey2.html">Tw2ColorKey2</a></li><li><a href="Tw2ColorSequencer.html">Tw2ColorSequencer</a></li><li><a href="Tw2CurveSet.html">Tw2CurveSet</a></li><li><a href="Tw2Device.html">Tw2Device</a></li><li><a href="Tw2Device_SetStandardStates.html">SetStandardStates</a></li><li><a href="Tw2DynamicEmitter.html">Tw2DynamicEmitter</a></li><li><a href="Tw2Effect.html">Tw2Effect</a></li><li><a href="Tw2EffectRes.html">Tw2EffectRes</a></li><li><a href="Tw2EulerRotation.html">Tw2EulerRotation</a></li><li><a href="Tw2EventCurve.html">Tw2EventCurve</a></li><li><a href="Tw2EventKey.html">Tw2EventKey</a></li><li><a href="Tw2Float.html">Tw2Float</a></li><li><a href="Tw2FloatParameter.html">Tw2FloatParameter</a></li><li><a href="Tw2ForwardingRenderBatch.html">Tw2ForwardingRenderBatch</a></li><li><a href="Tw2Frustum.html">Tw2Frustum</a></li><li><a href="Tw2GeometryAnimation.html">Tw2GeometryAnimation</a></li><li><a href="Tw2GeometryBatch.html">Tw2GeometryBatch</a></li><li><a href="Tw2GeometryBone.html">Tw2GeometryBone</a></li><li><a href="Tw2GeometryCurve.html">Tw2GeometryCurve</a></li><li><a href="Tw2GeometryLineBatch.html">Tw2GeometryLineBatch</a></li><li><a href="Tw2GeometryMesh.html">Tw2GeometryMesh</a></li><li><a href="Tw2GeometryMeshArea.html">Tw2GeometryMeshArea</a></li><li><a href="Tw2GeometryMeshBinding.html">Tw2GeometryMeshBinding</a></li><li><a href="Tw2GeometryModel.html">Tw2GeometryModel</a></li><li><a href="Tw2GeometryModel_FindBoneByName.html">FindBoneByName</a></li><li><a href="Tw2GeometryRes.html">Tw2GeometryRes</a></li><li><a href="Tw2GeometrySkeleton.html">Tw2GeometrySkeleton</a></li><li><a href="Tw2GeometryTrackGroup.html">Tw2GeometryTrackGroup</a></li><li><a href="Tw2GeometryTransformTrack.html">Tw2GeometryTransformTrack</a></li><li><a href="Tw2InstancedMesh.html">Tw2InstancedMesh</a></li><li><a href="Tw2InstancedMeshBatch.html">Tw2InstancedMeshBatch</a></li><li><a href="Tw2LoadingObject.html">Tw2LoadingObject</a></li><li><a href="Tw2MatrixParameter.html">Tw2MatrixParameter</a></li><li><a href="Tw2MayaAnimationEngine.html">Tw2MayaAnimationEngine</a></li><li><a href="Tw2MayaEulerRotationCurve.html">Tw2MayaEulerRotationCurve</a></li><li><a href="Tw2MayaScalarCurve.html">Tw2MayaScalarCurve</a></li><li><a href="Tw2MayaVector3Curve.html">Tw2MayaVector3Curve</a></li><li><a href="Tw2Mesh.html">Tw2Mesh</a></li><li><a href="Tw2MeshArea.html">Tw2MeshArea</a></li><li><a href="Tw2MeshLineArea.html">Tw2MeshLineArea</a></li><li><a href="Tw2Model.html">Tw2Model</a></li><li><a href="Tw2MotherLode.html">Tw2MotherLode</a></li><li><a href="Tw2ObjectReader.html">Tw2ObjectReader</a></li><li><a href="Tw2ParticleAttractorForce.html">Tw2ParticleAttractorForce</a></li><li><a href="Tw2ParticleDirectForce.html">Tw2ParticleDirectForce</a></li><li><a href="Tw2ParticleDragForce.html">Tw2ParticleDragForce</a></li><li><a href="Tw2ParticleElementDeclaration.html">Tw2ParticleElementDeclaration</a></li><li><a href="Tw2ParticleFluidDragForce.html">Tw2ParticleFluidDragForce</a></li><li><a href="Tw2ParticleSpring.html">Tw2ParticleSpring</a></li><li><a href="Tw2ParticleSystem.html">Tw2ParticleSystem</a></li><li><a href="Tw2ParticleSystem_GetInstanceBuffer.html">GetInstanceBuffer</a></li><li><a href="Tw2ParticleTurbulenceForce.html">Tw2ParticleTurbulenceForce</a></li><li><a href="Tw2PerlinCurve.html">Tw2PerlinCurve</a></li><li><a href="Tw2PerObjectData.html">Tw2PerObjectData</a></li><li><a href="Tw2PerObjectData_SetPerObjectDataToDevice.html">SetPerObjectDataToDevice</a></li><li><a href="Tw2PostProcess.html">Tw2PostProcess</a></li><li><a href="Tw2QuaternionCurve.html">Tw2QuaternionCurve</a></li><li><a href="Tw2QuaternionKey.html">Tw2QuaternionKey</a></li><li><a href="Tw2QuaternionKey2.html">Tw2QuaternionKey2</a></li><li><a href="Tw2QuaternionSequencer.html">Tw2QuaternionSequencer</a></li><li><a href="Tw2RandomConstantCurve.html">Tw2RandomConstantCurve</a></li><li><a href="Tw2RandomIntegerAttributeGenerator.html">Tw2RandomIntegerAttributeGenerator</a></li><li><a href="Tw2RandomUniformAttributeGenerator.html">Tw2RandomUniformAttributeGenerator</a></li><li><a href="Tw2RawData.html">Tw2RawData</a></li><li><a href="Tw2RenderBatch.html">Tw2RenderBatch</a></li><li><a href="Tw2RenderTarget.html">Tw2RenderTarget</a></li><li><a href="Tw2ResMan.html">Tw2ResMan</a></li><li><a href="Tw2Resource.html">Tw2Resource</a></li><li><a href="Tw2RGBAScalarSequencer.html">Tw2RGBAScalarSequencer</a></li><li><a href="Tw2RigidOrientation.html">Tw2RigidOrientation</a></li><li><a href="Tw2RotationCurve.html">Tw2RotationCurve</a></li><li><a href="Tw2RuntimeInstanceData.html">Tw2RuntimeInstanceData</a></li><li><a href="Tw2RuntimeInstanceData_SetData.html">SetData</a></li><li><a href="Tw2RuntimeInstanceData_SetItemElement.html">SetItemElement</a></li><li><a href="Tw2RuntimeInstanceData_SetItemElementRef.html">SetItemElementRef</a></li><li><a href="Tw2SamplerOverride.html">Tw2SamplerOverride</a></li><li><a href="Tw2SamplerState.html">Tw2SamplerState</a></li><li><a href="Tw2ScalarCurve.html">Tw2ScalarCurve</a></li><li><a href="Tw2ScalarCurve2.html">Tw2ScalarCurve2</a></li><li><a href="Tw2ScalarKey.html">Tw2ScalarKey</a></li><li><a href="Tw2ScalarKey2.html">Tw2ScalarKey2</a></li><li><a href="Tw2ScalarSequencer.html">Tw2ScalarSequencer</a></li><li><a href="Tw2SineCurve.html">Tw2SineCurve</a></li><li><a href="Tw2SphereShapeAttributeGenerator.html">Tw2SphereShapeAttributeGenerator</a></li><li><a href="Tw2StaticEmitter.html">Tw2StaticEmitter</a></li><li><a href="Tw2TextureParameter.html">Tw2TextureParameter</a></li><li><a href="Tw2TextureParameter_SetTexturePath.html">SetTexturePath</a></li><li><a href="Tw2TextureRes.html">Tw2TextureRes</a></li><li><a href="Tw2TextureRes_Attach.html">Attach</a></li><li><a href="Tw2TextureRes_Bind.html">Bind</a></li><li><a href="Tw2TextureRes_Unload.html">Unload</a></li><li><a href="Tw2Torque.html">Tw2Torque</a></li><li><a href="Tw2Track.html">Tw2Track</a></li><li><a href="Tw2TrackGroup.html">Tw2TrackGroup</a></li><li><a href="Tw2TransformParameter.html">Tw2TransformParameter</a></li><li><a href="Tw2TransformParameter_Apply.html">Apply</a></li><li><a href="Tw2TransformTrack.html">Tw2TransformTrack</a></li><li><a href="Tw2ValueBinding.html">Tw2ValueBinding</a></li><li><a href="Tw2VariableParameter.html">Tw2VariableParameter</a></li><li><a href="Tw2VariableStore.html">Tw2VariableStore</a></li><li><a href="Tw2VariableStore_RegisterType.html">RegisterType</a></li><li><a href="Tw2VariableStore_RegisterVariable.html">RegisterVariable</a></li><li><a href="Tw2VariableStore_RegisterVariableWithType.html">RegisterVariableWithType</a></li><li><a href="Tw2Vector2Curve.html">Tw2Vector2Curve</a></li><li><a href="Tw2Vector2Key.html">Tw2Vector2Key</a></li><li><a href="Tw2Vector2Parameter.html">Tw2Vector2Parameter</a></li><li><a href="Tw2Vector3Curve.html">Tw2Vector3Curve</a></li><li><a href="Tw2Vector3Key.html">Tw2Vector3Key</a></li><li><a href="Tw2Vector3Parameter.html">Tw2Vector3Parameter</a></li><li><a href="Tw2Vector4Parameter.html">Tw2Vector4Parameter</a></li><li><a href="Tw2VectorCurve.html">Tw2VectorCurve</a></li><li><a href="Tw2VectorKey.html">Tw2VectorKey</a></li><li><a href="Tw2VectorSequencer.html">Tw2VectorSequencer</a></li><li><a href="Tw2VertexDeclaration.html">Tw2VertexDeclaration</a></li><li><a href="Tw2VertexElement.html">Tw2VertexElement</a></li><li><a href="Tw2WbgTrack.html">Tw2WbgTrack</a></li><li><a href="Tw2WbgTransformTrack.html">Tw2WbgTransformTrack</a></li><li><a href="Tw2XYZScalarSequencer.html">Tw2XYZScalarSequencer</a></li><li><a href="Tw2YPRSequencer.html">Tw2YPRSequencer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ag_horner1">ag_horner1</a></li><li><a href="global.html#ag_zeroin">ag_zeroin</a></li><li><a href="global.html#ag_zeroin2">ag_zeroin2</a></li><li><a href="global.html#emitter">emitter</a></li><li><a href="global.html#EveStation">EveStation</a></li><li><a href="global.html#EveTurretSetLocatorInfo">EveTurretSetLocatorInfo</a></li><li><a href="global.html#Inherit">Inherit</a></li><li><a href="global.html#Perlin_init">Perlin_init</a></li><li><a href="global.html#Perlin_noise1">Perlin_noise1</a></li><li><a href="global.html#PerlinNoise1D">PerlinNoise1D</a></li><li><a href="global.html#polyZeroes">polyZeroes</a></li><li><a href="global.html#Tw2AnimationController">Tw2AnimationController</a></li><li><a href="global.html#Tw2EventEmitter">Tw2EventEmitter</a></li><li><a href="global.html#vec3Hermite">vec3Hermite</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun May 07 2017 02:25:29 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
